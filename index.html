<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SALTY AR - WRISTWATCH</title>
    
    <!-- AI Library -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1);
            z-index: -1; filter: brightness(0.1) contrast(1.2);
        }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        #header { position: absolute; top: 40px; left: 40px; pointer-events: none; z-index: 10; }
        
        h1 {
            margin: 0; font-size: 4rem; 
            color: #d8b5ff; 
            text-shadow: 0 0 10px #fff, 0 0 20px #b026ff, 0 0 40px #8000ff;
            font-weight: 900; letter-spacing: 5px; font-style: italic;
        }

        #controls {
            position: absolute; bottom: 40px; width: 100%; text-align: center;
            z-index: 20; pointer-events: none;
        }
    </style>
</head>
<body>

    <video id="webcam" playsinline></video>

    <div id="header">
        <h1>SALTY</h1>
    </div>

    <div id="controls"></div>

    <!-- SHADER -->
    <script type="x-shader/x-vertex" id="vertexShader">
        attribute float size;
        attribute vec3 customColor;
        // type: 0=Text, 1=Watch Structure
        attribute float type; 
        
        varying vec3 vColor;
        varying float vAlpha;
        
        uniform float uTime;
        uniform float uJitter; 

        void main() {
            vColor = customColor;
            vec3 pos = position;

            // Quantum Jitter
            if (uJitter > 0.0) {
                 float intensity = (type > 0.5) ? 0.3 : 0.05; 
                 float vib = sin(uTime * 30.0 + position.y * 10.0 + position.x * 20.0);
                 pos += vec3(vib * intensity * uJitter);
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            float distSize = 400.0 / -mvPosition.z;
            
            // Watch Pulse vs Text Pulse
            float pulseSpeed = (type > 0.5) ? 4.0 : 2.0; 
            float pulse = 1.0 + sin(uTime * pulseSpeed + position.x * 0.5) * 0.15;
            
            gl_PointSize = size * pulse * distSize;
            vAlpha = smoothstep(90.0, 5.0, -mvPosition.z);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
            vec4 tex = texture2D(pointTexture, gl_PointCoord);
            gl_FragColor = vec4(vColor, vAlpha) * tex;
            if(gl_FragColor.a < 0.05) discard;
        }
    </script>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- GLOBAL ---
        let spinVelX=0, spinVelY=0, decay=0.96;
        let currentExpansion = 0.0;
        let prevHandX=0.5, prevHandY=0.5;
        let handOpenness=0.0;
        let isHandDetected=false;

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.z = 24;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // --- FLARE ---
        function createFlare() {
            const s=64; const c=document.createElement('canvas');
            c.width=s; c.height=s;
            const ctx=c.getContext('2d');
            const g=ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.3,'rgba(255,255,255,0.4)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,s,s);
            return new THREE.CanvasTexture(c);
        }
        const tex = createFlare();

        // --- TEXT DATA ---
        function getTextCoordinates() {
            const W=600, H=200;
            const c=document.createElement('canvas');
            c.width=W; c.height=H;
            const ctx=c.getContext('2d');
            ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
            ctx.font='900 130px Arial'; 
            ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillStyle='#fff'; ctx.fillText('SALTY', W/2, H/2);
            
            const data = ctx.getImageData(0,0,W,H).data;
            const points = [];
            for(let y=0; y<H; y+=2) {
                for(let x=0; x<W; x+=2) {
                    if(data[(y*W+x)*4]>128) {
                        points.push({ x: (x - W/2) * 0.05, y: ((H-y) - H/2) * 0.05, z: 0 });
                    }
                }
            }
            return points;
        }
        const textPoints = getTextCoordinates();

        // --- WATCH SYSTEM GENERATOR (UPDATED FOR BRACELET) ---
        function createWatchSystem() {
            const textBaseCount = textPoints.length; 
            const debrisCount = 12000; // Increased count slightly for bracelet
            const total = textBaseCount + debrisCount;

            const pos = new Float32Array(total * 3);
            const col = new Float32Array(total * 3);
            const size = new Float32Array(total);
            const type = new Float32Array(total); 
            const meta = new Float32Array(total * 4); 
            const orig = new Float32Array(total * 3);

            const R_WATCH = 7.0;

            for(let i=0; i<total; i++) {
                
                let sx, sy, sz;
                const rnd = Math.random();

                // === SHAPE DISTRIBUTION ===
                // 40% Bezel (Face Ring)
                // 30% Bracelet (NEW STRAP)
                // 15% Ticks/Hands
                // 15% Glass

                if (rnd < 0.4) {
                    // === BEZEL ===
                    const theta = Math.random() * Math.PI * 2;
                    const r = R_WATCH + (Math.random()-0.5) * 1.5;
                    sx = r * Math.cos(theta);
                    sy = r * Math.sin(theta);
                    sz = (Math.random()-0.5)*0.5;
                } 
                else if (rnd < 0.7) {
                    // === BRACELET (STRAP) ===
                    // A loop perpendicular to face, sitting behind it
                    const theta = Math.random() * Math.PI * 2;
                    
                    // Wrist radius roughly same as watch
                    const rWrist = R_WATCH * 0.85; 
                    
                    // Strap Width (along X axis) - narrower than the face
                    sx = (Math.random()-0.5) * 5.5; 
                    
                    // The loop is on Y-Z axis
                    sy = rWrist * Math.cos(theta); 
                    
                    // Push Z back so the bracelet sits behind the face center
                    // We offset by radius so the 'front' of the strap touches back of watch
                    sz = (rWrist * Math.sin(theta)) - 5.0; 

                    // Add thickness/volume to strap
                    sz += (Math.random()-0.5);
                }
                else if (rnd < 0.85) {
                    // === TICKS & HANDS ===
                    if(Math.random() > 0.4) {
                        // TICKS
                        const hour = Math.floor(Math.random()*12);
                        const theta = (hour / 12) * Math.PI * 2;
                        const r = (R_WATCH * 0.8) + Math.random(); 
                        sx = r * Math.cos(theta);
                        sy = r * Math.sin(theta);
                        sz = 0.5;
                    } else {
                        // HANDS
                        const isMin = Math.random() > 0.5;
                        const angle = isMin ? 0.5 : 2.6; 
                        const len = isMin ? R_WATCH * 0.7 : R_WATCH * 0.5;
                        const dist = Math.random() * len;
                        sx = dist * Math.cos(angle);
                        sy = dist * Math.sin(angle);
                        sz = 0.8; 
                    }
                } else {
                    // === FACE FILL ===
                    const theta = Math.random() * Math.PI * 2;
                    const r = Math.sqrt(Math.random()) * (R_WATCH - 1.0);
                    sx = r * Math.cos(theta);
                    sy = r * Math.sin(theta);
                    sz = (Math.random()-0.5)*0.2;
                }

                const i3=i*3; const i4=i*4;
                pos.set([sx,sy,sz], i3);
                orig.set([sx,sy,sz], i3);

                // --- TYPES ---
                if (i < textBaseCount) {
                    // TYPE 0: TEXT (Hidden inside Watch until explode)
                    const t = textPoints[i];
                    type[i] = 0.0;
                    meta.set([t.x, t.y, t.z, 0], i4);
                    
                    if (Math.random() > 0.5) col.set([0.85, 0.7, 1.0], i3);
                    else col.set([0.7, 0.4, 1.0], i3);
                    size[i] = 0.6; 

                } else {
                    // TYPE 1: WATCH SHRAPNEL (Gold)
                    type[i] = 1.0; 
                    
                    const v = new THREE.Vector3(sx,sy,sz).normalize();
                    v.x += (Math.random()-0.5); 
                    v.y += (Math.random()-0.5);
                    v.z += (Math.random()-0.5)*3.0; 
                    v.normalize();

                    const speed = 1.0 + Math.random()*2.5; 
                    meta.set([v.x, v.y, v.z, speed], i4);

                    // COLOR: Gold
                    if (Math.random() > 0.7) col.set([1.0, 0.9, 0.5], i3); 
                    else if (Math.random() > 0.3) col.set([1.0, 0.7, 0.0], i3); 
                    else col.set([0.8, 0.5, 0.2], i3); 
                    
                    size[i] = 0.3 + Math.random()*0.4;
                }
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('customColor', new THREE.BufferAttribute(col, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(size, 1));
            geo.setAttribute('type', new THREE.BufferAttribute(type, 1));

            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: tex },
                    uTime: { value: 0 },
                    uJitter: { value: 0 }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });

            const mesh = new THREE.Points(geo, mat);
            mesh.userData = { orig, meta, types: type }; 
            return mesh;
        }

        const sys = createWatchSystem(); 
        scene.add(sys);


        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            sys.material.uniforms.uTime.value = time;

            // Rotation
            sys.rotation.z -= 0.0; 
            sys.rotation.y += spinVelX;
            sys.rotation.x += spinVelY;
            
            spinVelX *= decay; 
            spinVelY *= decay;

            // Input Handlers
            const isSwiping = Math.abs(spinVelX) > 0.05 || Math.abs(spinVelY) > 0.05;
            
            if (isHandDetected) {
                const motionJitter = (Math.abs(spinVelX)+Math.abs(spinVelY)) * 0.5;
                sys.material.uniforms.uJitter.value = (handOpenness * 0.5) + motionJitter;

                if (!isSwiping) {
                    const target = handOpenness; 
                    currentExpansion += (target - currentExpansion) * 0.08;
                }
            } else {
                currentExpansion += (0 - currentExpansion) * 0.05;
                sys.rotation.y -= 0.001; 
                sys.material.uniforms.uJitter.value = 0;
            }

            // Positions Update
            const pos = sys.geometry.attributes.position.array;
            const orig = sys.userData.orig;
            const meta = sys.userData.meta;
            const types = sys.userData.types;
            const count = sys.geometry.attributes.position.count;

            const textProgress = smoothstep(0.1, 0.95, currentExpansion);

            for(let i=0; i<count; i++) {
                const i3=i*3; const i4=i*4;
                const ox=orig[i3], oy=orig[i3+1], oz=orig[i3+2];
                const mx=meta[i4], my=meta[i4+1], mz=meta[i4+2], val=meta[i4+3];
                const t = types[i];

                if (t < 0.5) { 
                    // TEXT
                    pos[i3]   = ox + (mx - ox) * textProgress;
                    pos[i3+1] = oy + (my - oy) * textProgress;
                    pos[i3+2] = oz + (mz - oz) * textProgress;
                    
                    if (currentExpansion > 0.8) pos[i3+1] += Math.sin(time*2.0 + ox)*0.015;

                } else { 
                    // WATCH DEBRIS
                    const dist = currentExpansion * val * 90.0; 
                    pos[i3]   = ox + mx * dist;
                    pos[i3+1] = oy + my * dist;
                    pos[i3+2] = oz + mz * dist;
                }
            }
            sys.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }
        
        function smoothstep(min, max, value) {
            var x = Math.max(0, Math.min(1, (value-min)/(max-min)));
            return x*x*(3 - 2*x);
        }

        animate();


        // --- INPUTS ---
        window.onresize = () => { 
            camera.aspect=window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        };

        const video = document.getElementById('webcam');
        function onResults(res) {
            if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const lm = res.multiHandLandmarks[0];
                const cx = 1.0 - lm[9].x; const cy = lm[9].y;

                // Physics Spin
                const dx = cx - prevHandX; const dy = cy - prevHandY;
                if(Math.abs(dx)>0.004 || Math.abs(dy)>0.004) {
                    spinVelX += dx * 0.8; 
                    spinVelY += dy * 0.8;
                    spinVelX = Math.max(-0.6, Math.min(0.6, spinVelX));
                    spinVelY = Math.max(-0.6, Math.min(0.6, spinVelY));
                }
                prevHandX=cx; prevHandY=cy;

                const w=lm[0], t=lm[12], b=lm[9]; 
                const full = Math.hypot(w.x-t.x, w.y-t.y);
                const palm = Math.hypot(w.x-b.x, w.y-b.y);
                handOpenness = Math.max(0, Math.min(1, (full/palm - 1.0)/0.7));

            } else { isHandDetected = false; }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5});
        hands.onResults(onResults);
        
        const cam = new Camera(video, {onFrame:async()=>{await hands.send({image:video})}, width:1280, height:720});
        cam.start();

    </script>
</body>
</html>
